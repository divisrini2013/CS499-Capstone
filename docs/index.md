CS 499 Final Project
Professional Self-Assessment
Divya Rangaraj

 
Introduction
Computer Science at Southern New Hampshire University impacted my profession, technical skills, and identity. This education taught me software engineering, algorithms, data structures, databases, cybersecurity, cooperation, and technical communication. Capstone and ePortfolio helped me use these abilities professionally. It forced me critically assess my work, improve it to industry standards, and reflect on software engineering progress. This self-assessment includes my ePortfolio and computer science skills. Additionally, my updated portfolio materials demonstrate my talents, passion to progress, and software development efforts.
1. Collaboration and Team Environments
I worked in teams throughout my degree, even for single projects. In CS 250: Software Development Lifecycle and IT 315: Object-Oriented Analysis and Design, group discussions, design reviews, and collaborative requirement-gathering required communication, collaboration, and accountability.
These collaborative settings taught me how to discuss issues and express my thoughts to big groups. Git and GitHub handle shared code, I learnt. During collaborative design projects, I forked, handled merge conflicts, and annotated code to express my opinions. I learned that software development involves cooperation, shared knowledge, and flexibility from these collaborations.
The capstone enhanced these talents. Even if final adjustments are made individually, the capstone setting is like a professional team where peers, professors, and future stakeholders must work together. A code review video tour for peers, supervisors, and technical recruiters was required. I tried teaching challenging technical subjects in actual firms to increase teamwork.
2. Communication With Stakeholders
Computer scientists must communicate with techies and non-techies. Code reviews, software presentations, written documentation, and coordinated project reports improved these abilities.
In CS 320: Software Testing, Automation, and Quality Assurance, I explained test methodology and outcomes to non-technical customers and project managers. In CS 330: Computational Graphics and Visualization, I taught developers and end users visual components, rendering pipelines, and interactive features.
Building the capstone ePortfolio needs focused communication. I needed narratives that validated my improvements, linked them to course outcomes, and made sense to recruiters, hiring managers, and technical experts. My code review video demonstrated the need of explaining technical ideas without overwhelming viewers.
These experiences have prepared me for CEO explanations and development team technical discussions. Decision-making at business requires good communication.
3. Algorithms, Data Structures, and Computational Thinking
My algorithm creation, analysis, and optimization skills improved during the training. I learned computational trade-offs, algorithmic efficiency, and data structure selection in CS 260 and CS 370.
The Q-Learning reinforcement-learning function enhancement in my capstone project shows this tendency. Early monolithic code lacked efficient data structures and flexible algorithmic reasoning. Knowing algorithmic techniques may enhance this item:
•	strategy exploration vs. exploitation
•	neural network-based Q-value calculations
•	batch training, memory replay
•	dynamic state transitions
•	efficient queue-like memory structures.
Dequered unnecessary list-based memory, modularized the training pipeline into helper functions, smoothed epsilon decay, introduced visualization tools, and checked input. These changes demonstrate my ability to organize algorithm logic and build optimal, maintainable, and mathematically correct solutions. AI, full-stack development, and data engineering need computational thinking and problem-solving.
4. Software Engineering and System Design
This course taught software engineering fundamentals including design patterns, modularity, testing, and documentation. Instead of merely code, CS 340: Advanced Programming Concepts and CS 320: Software Testing helped me develop controllable, scalable, and secure systems.
The MongoDB CRUD capstone enhancement shows this. Security, modules, and error handling were absent in the original product. I applied professional engineering principles to enhancement: environment credential management, modular class restructure for concern separation, Python's logging package for structured logging, validation and defensive programming for exception handling, and PyTest and mongomock testability improvements.
A basic academic script was production-ready following these revisions. They demonstrate my abilities to assess systems, find flaws, and solve them using software engineering best practices.
5. Databases and Information Systems
Most applications need relational and NoSQL databases, which I learned in DAD 220: Introduction to SQL and CS 340. I studied data integrity, query optimization, normalization, indexing, and schema design.
In the capstone, I used secure environment variable storage for database credentials, indexing fields for faster searches, schema-inspired data-validation rules, improved exception handling for data consistency, and MongoDB data access pattern optimization.
These improvements demonstrate my database administration, security, and optimization skills. They show my ability to support professional data-driven systems.
6. Developing a Security Mindset
Security courses like CS 405: Secure Coding and IT 380: Cybersecurity and Information Assurance helped me create secure software solutions. I learnt how attackers exploit weaknesses and how secure-coding avoids them.
Improving my capstone for security:
•	I used environment variables instead of credentials.
•	To avoid data exposure, I handled errors.
•	I implemented input validation to prevent bad queries.
•	I utilized defensive programming in RL and database.
I demonstrated that security is a development responsibility by using these methods.
How My Artifacts Fit Together
My three ePortfolio artifacts show my technological versatility:
1.	Software Engineering (CRUD Module Enhancement): Shows secure, maintainable backend development.
2.	Algorithms and Data Structures (Q-Learning Enhancement): Shows optimized algorithmic design and computational reasoning.
3.	Databases (MongoDB Integration Enhancement): Shows database engineering, schema awareness, and secure data handling.
They show my backend programming, machine learning, and database system talents, preparing me for software engineering. They achieve cooperation, communication, algorithmic design, tool competency, and security course objectives.
Conclusion
Finishing computer science and my capstone ePortfolio transformed my academic route. It let me show off my computer science skills after years of study. I upgraded my software engineering, algorithms, databases, security, communication, and teamwork. More significantly, the program set my career ambitions. Software engineering, backend programming, and data-driven system design are now my skills. My updated ePortfolio and industry-quality artifacts give me confidence to join the field and work on genuine projects.
